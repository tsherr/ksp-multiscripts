{CSS Dynamic Crossfade Fix
	This multi script fixes an issue with Cinematic Studio Strings in which dynamic layers can still be crossfaded even if no notes are playing.
	This creates an effect where the natural note decays (tails after a note-off) don't decay at the expected levels, and instead decay at whatever dynamic layer is currently active.
	For example, ramping up the dynamic layer CC right after a note-off causes that note's decay tail to get louder as it plays out. 
	Or, ramping down the dynamic layer CC right after a note-off causes that note's decay tail to get soft too fast.
	The dynamic layer should not change if no notes are playing, so the solution is to filter out dynamic CC changes if no notes are playing. 
	As soon as a note breaks the silence, the most recent dynamics CC value should be processed.

	Version History:
		v0.2: Fixed an edge-case where the script would think a negative number of notes were being held.
		v0.1: initial implementation
}

{ #pragma save_compiled_source css_dynamic_crossfade_fix.txt }

on init

	define FALSE := 0
	define TRUE := 1
	define NUM_CHANNELS := 64

	define SCRIPT_TITLE := "CSS DC FX"
	define VERSION_STRING := "v0.2"
	
	set_script_title(SCRIPT_TITLE & " " & VERSION_STRING)

	declare ui_label la_Info(4, 4)
	la_Info -> text := "This multi script fixes an issue with Cinematic Studio Strings in which dynamic layers can still be crossfaded even if no notes are playing. In the following box, indicate which CC to monitor for dynamics crossfade changes."

	declare ui_label la_ChannelSelect(1, 1)
    la_ChannelSelect -> x := 440
    la_ChannelSelect -> y := 5
    la_ChannelSelect -> width := 100
    la_ChannelSelect -> text := "Channel: "

	declare ui_menu me_ChannelSelect
    me_ChannelSelect -> x := 540
    me_ChannelSelect -> y := 5
    me_ChannelSelect -> width := 60

    //Populate channel menu
    declare i
    for i := 0 to (NUM_CHANNELS - 1)    
		select (i)
			case 0 to 15
				add_menu_item(me_ChannelSelect,"[A] " & (i mod 16) + 1, i)
			case 16 to 31
				add_menu_item(me_ChannelSelect,"[B] " & (i mod 16) + 1, i)
			case 32 to 47
				add_menu_item(me_ChannelSelect,"[C] " & (i mod 16) + 1, i)
			case 48 to 63
				add_menu_item(me_ChannelSelect,"[D] " & (i mod 16) + 1, i)
			end select
	end for

	declare pers ui_value_edit va_DynamicsCrossfadeCC(0, 127, 1)
	va_DynamicsCrossfadeCC -> text := "Crossfade CC#"
	va_DynamicsCrossfadeCC -> x := 440
	va_DynamicsCrossfadeCC -> y := 25
	va_DynamicsCrossfadeCC -> width := 160

	declare ui_button bu_DynamicsCrossfadeCCLearn
	bu_DynamicsCrossfadeCCLearn -> text := "Lrn"
	bu_DynamicsCrossfadeCCLearn -> x := (va_DynamicsCrossfadeCC -> x) + (va_DynamicsCrossfadeCC -> width) + 3
	bu_DynamicsCrossfadeCCLearn -> y := (va_DynamicsCrossfadeCC -> y)
	bu_DynamicsCrossfadeCCLearn -> width := 28

	declare pers ui_value_edit va_PlayingRangeLowKey(0, 127, 1)
	va_PlayingRangeLowKey -> text := "Playing range low key"
	va_PlayingRangeLowKey -> x := 440
	va_PlayingRangeLowKey -> y := 45
	va_PlayingRangeLowKey -> width := 160

	declare ui_button bu_PlayingRangeLowKeyLearn
	bu_PlayingRangeLowKeyLearn -> text := "Lrn"
	bu_PlayingRangeLowKeyLearn -> x := (va_PlayingRangeLowKey -> x) + (va_PlayingRangeLowKey -> width) + 3
	bu_PlayingRangeLowKeyLearn -> y := (va_PlayingRangeLowKey -> y)
	bu_PlayingRangeLowKeyLearn -> width := 28

	declare pers ui_value_edit va_PlayingRangeHighKey(0, 127, 1)
	va_PlayingRangeHighKey -> text := "Playing range high key"
	va_PlayingRangeHighKey -> x := 440
	va_PlayingRangeHighKey -> y := 65
	va_PlayingRangeHighKey -> width := 160
	va_PlayingRangeHighKey := 127

	declare ui_button bu_PlayingRangehighKeyLearn
	bu_PlayingRangehighKeyLearn -> text := "Lrn"
	bu_PlayingRangehighKeyLearn -> x := (va_PlayingRangeHighKey -> x) + (va_PlayingRangeHighKey -> width) + 3
	bu_PlayingRangehighKeyLearn -> y := (va_PlayingRangeHighKey -> y)
	bu_PlayingRangehighKeyLearn -> width := 28

	declare pers dynamicsCrossfadeCCs[NUM_CHANNELS]
	declare pers playingRangeLowKey[NUM_CHANNELS]
	declare pers playingRangeHighKey[NUM_CHANNELS]
	declare pers lastDynamicsCrossfadeCCValue[NUM_CHANNELS];
	declare keyCounter[NUM_CHANNELS];
	declare temp

	//Initialization
	for i := 0 to num_elements(playingRangeHighKey) - 1
		playingRangeHighKey[i] := 127
	end for

end on

function NoNotesArePlaying(channel) -> result

	//There are sometimes cases where kontakt will stop the notes even if the physical keys are down. This prevents such a scenario which would allowing a negative number of notes to be held
	if (keyCounter[channel] < 0)
		keyCounter[channel] := 0
	end if

	if keyCounter[channel] = 0
		result := TRUE
	else
		result := FALSE
	end if
end function

on ui_control(va_DynamicsCrossfadeCC)
	dynamicsCrossfadeCCs[me_ChannelSelect] := va_DynamicsCrossfadeCC
end on

on ui_control(va_PlayingRangeLowKey)
	playingRangeLowKey[me_ChannelSelect] := va_PlayingRangeLowKey
end on

on ui_control(va_PlayingRangeHighKey)
	playingRangeHighKey[me_ChannelSelect] := va_PlayingRangeHighKey
end on

on ui_control(me_ChannelSelect)
	va_DynamicsCrossfadeCC := dynamicsCrossfadeCCs[me_ChannelSelect]
	va_PlayingRangeLowKey := playingRangeLowKey[me_ChannelSelect]
	va_PlayingRangeHighKey := playingRangeHighKey[me_ChannelSelect]
end on


on midi_in

	if (MIDI_COMMAND = MIDI_COMMAND_CC and bu_DynamicsCrossfadeCCLearn = TRUE) //Learn CC
		dynamicsCrossfadeCCs[me_ChannelSelect] := MIDI_BYTE_1
		va_DynamicsCrossfadeCC := MIDI_BYTE_1
		bu_DynamicsCrossfadeCCLearn := FALSE
		exit
	end if

	if (MIDI_COMMAND = MIDI_COMMAND_CC and MIDI_BYTE_1 = dynamicsCrossfadeCCs[MIDI_CHANNEL]) //Dynamics crossfade CC

		//Save most recent dynamics crossfade CC value
		lastDynamicsCrossfadeCCValue[MIDI_CHANNEL] := MIDI_BYTE_2

		//Only allow the crossfade value to pass through if notes are playing
		temp := NoNotesArePlaying(MIDI_CHANNEL)
		if temp = TRUE
			ignore_midi
		end if

	end if

	if (MIDI_COMMAND = MIDI_COMMAND_NOTE_ON and MIDI_BYTE_2 > 0) //Note on

		//Learn low key
		if (bu_PlayingRangeLowKeyLearn = TRUE)
			playingRangeLowKey[me_ChannelSelect] := MIDI_BYTE_1
			va_PlayingRangeLowKey := MIDI_BYTE_1
			bu_PlayingRangeLowKeyLearn := FALSE
			ignore_midi
		end if

		//Learn high key
		if (bu_PlayingRangeHighKeyLearn = TRUE)
			playingRangeHighKey[me_ChannelSelect] := MIDI_BYTE_1
			va_PlayingRangeHighKey := MIDI_BYTE_1
			bu_PlayingRangeHighKeyLearn := FALSE
			ignore_midi
		end if
		
		if (MIDI_BYTE_1 >= playingRangeLowKey[MIDI_CHANNEL] and MIDI_BYTE_1 <= playingRangeHighKey[MIDI_CHANNEL])		
		
			//If this is the first note of a phrase (this note breaks the silence), first process the most recent dynamics crossfade value then process the note
			temp := NoNotesArePlaying(MIDI_CHANNEL)
			if temp = TRUE
				ignore_midi			
				set_midi(MIDI_CHANNEL, MIDI_COMMAND_CC, dynamicsCrossfadeCCs[MIDI_CHANNEL], lastDynamicsCrossfadeCCValue[MIDI_CHANNEL])
				set_midi(MIDI_CHANNEL, MIDI_COMMAND_NOTE_ON, MIDI_BYTE_1, MIDI_BYTE_2)
			end if

			keyCounter[MIDI_CHANNEL] := keyCounter[MIDI_CHANNEL] + 1 //Keep track of how many notes are playing
		end if

	end if

	if (MIDI_COMMAND = MIDI_COMMAND_NOTE_OFF or (MIDI_COMMAND = MIDI_COMMAND_NOTE_ON and MIDI_BYTE_2 = 0)) //Note off
		
		if (MIDI_BYTE_1 >= playingRangeLowKey[MIDI_CHANNEL] and MIDI_BYTE_1 <= playingRangeHighKey[MIDI_CHANNEL])	
			keyCounter[MIDI_CHANNEL] := keyCounter[MIDI_CHANNEL] - 1 //Keep track of how many notes are playing
		end if

	end if

end on

